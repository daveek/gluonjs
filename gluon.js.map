{"version":3,"names":[],"mappings":"","sources":["gluon.js"],"sourcesContent":["import { render, html } from '../lit-html/lit-html.js';\n\nexport { html };\n\nconst TAG = Symbol('tag');\nconst NEEDSRENDER = Symbol('needsRender');\nconst SHADYTEMPLATE = Symbol('shadyTemplate');\n\nconst applyShadyCSS = element => {\n  if (window.ShadyCSS) {\n    const klass = element.constructor;\n    if (klass[SHADYTEMPLATE] === undefined) {\n      klass[SHADYTEMPLATE] = document.createElement('template');\n      klass[SHADYTEMPLATE].innerHTML = element.shadowRoot.innerHTML;\n      ShadyCSS.prepareTemplate(klass[SHADYTEMPLATE], klass.is);\n    }\n    ShadyCSS.styleElement(element);\n  }\n};\n\nconst camelToKebab = function(camel) {\n  return camel.replace(/([a-z])([A-Z])|(.)([A-Z][a-z])/g, '$1$3-$2$4').toLowerCase();\n};\n\nconst createIdCache = function(element) {\n  element.$ = {};\n  element.shadowRoot.querySelectorAll('[id]').forEach(el => {\n    element.$[el.id] = el;\n  });\n};\n\nexport class GluonElement extends HTMLElement {\n  static get is() {\n    return (this.hasOwnProperty(TAG) && this[TAG]) || (this[TAG] = camelToKebab(this.name));\n  }\n  connectedCallback() {\n    if ('template' in this) {\n      this.attachShadow({ mode: 'open' });\n      this.render({ sync: true });\n      createIdCache(this);\n    }\n  }\n  // Render the element's template.\n  // By default, renders are asynchronous and executed at the next microtask timing,\n  // so multiple render calls are batched.\n  // If the sync option is set to `true`, it renders synchronously instead.\n  // Returns a Promise that resolves when the render is completed.\n  async render({ sync = false } = {}) {\n    this[NEEDSRENDER] = true;\n    if (!sync) {\n      await 0;\n    }\n    if (this[NEEDSRENDER]) {\n      this[NEEDSRENDER] = false;\n      render(this.template, this.shadowRoot);\n      applyShadyCSS(this);\n    }\n  }\n}\n"],"file":"gluon.js"}